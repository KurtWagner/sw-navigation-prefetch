{"version":3,"sources":["webpack:///sw-navigation-prefetch.js","webpack:///webpack/bootstrap 8f7258cd5517919a986e","webpack:///./lib/logger.js","webpack:///./lib/listeners/fetch.js","webpack:///./lib/models/prefetch.js","webpack:///./lib/models/cache.js","webpack:///./lib/models/route.js","webpack:///./lib/sw-navigation-prefetch.js","webpack:///./~/path-to-regexp/index.js","webpack:///./~/path-to-regexp/~/isarray/index.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","Logger","this","debug","_messagePrefix","_console","_len","arguments","messages","Array","_key","console","warn","apply","concat","_console2","_len2","_key2","log","time","timeEnd","navigationPrefetch","event","request","mode","referrer","url","prefetchRoutes","prefetchedPromise","provideRoutes","respondWith","Route","Cache","logger","Prefetch","_ref","location","_cache","_routes","_location","routePath","makeRequests","routeURL","URL","origin","route","push","responsePromise","matchOnce","then","response","clone","navigationRequest","_this","forEach","matchesRequest","requests","addAll","set","_toConsumableArray","arr","isArray","arr2","from","_store","Map","_cacheExpiryMS","values","map","found","cancelExpiration","delete","fetch","timeoutId","setTimeout","clearTimeout","_this2","add","makeURL","_ref3","urlOrPath","startsWith","makeRequest","headers","Headers","append","Request","credentials","getReferrerFromRequest","_routeURL","_makeRequests","_ref2","Set","rawUrl","requestURL","pathToRegexp","regex","pathname","match","makeFetchListener","self","addEventListener","parse","str","options","res","tokens","index","path","defaultDelimiter","delimiter","PATH_REGEXP","exec","escaped","offset","slice","next","prefix","capture","group","modifier","asterisk","partial","repeat","optional","pattern","escapeGroup","escapeString","substr","compile","tokensToFunction","encodeURIComponentPretty","encodeURI","replace","charCodeAt","toString","toUpperCase","encodeAsterisk","matches","RegExp","obj","opts","data","encode","pretty","encodeURIComponent","token","segment","isarray","JSON","stringify","j","test","attachKeys","re","keys","flags","sensitive","regexpToRegexp","groups","source","arrayToRegexp","parts","join","stringToRegexp","tokensToRegExp","strict","end","endsWithDelimiter"],"mappings":"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","file":"sw-navigation-prefetch.js","sourcesContent":["/*!\n * \n * Copyright 2017 Kurt Wagner. All rights reserved\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n * http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * \t\t\n */\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*\n\tCopyright 2017 Kurt Wagner. All rights reserved\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\thttp://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nmodule.exports = new (function () {\n\tfunction Logger() {\n\t\t_classCallCheck(this, Logger);\n\n\t\tthis.debug = false;\n\t\tthis._messagePrefix = 'sw-navigation-prefetch: ';\n\t}\n\n\t_createClass(Logger, [{\n\t\tkey: 'warn',\n\t\tvalue: function warn() {\n\t\t\tvar _console;\n\n\t\t\tfor (var _len = arguments.length, messages = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\t\tmessages[_key] = arguments[_key];\n\t\t\t}\n\n\t\t\t(_console = console).warn.apply(_console, [this._messagePrefix].concat(messages));\n\t\t}\n\t}, {\n\t\tkey: 'log',\n\t\tvalue: function log() {\n\t\t\tif (this.debug) {\n\t\t\t\tvar _console2;\n\n\t\t\t\tfor (var _len2 = arguments.length, messages = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t\t\t\t\tmessages[_key2] = arguments[_key2];\n\t\t\t\t}\n\n\t\t\t\t(_console2 = console).log.apply(_console2, [this._messagePrefix].concat(messages));\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'time',\n\t\tvalue: function time(name) {\n\t\t\tif (this.debug) {\n\t\t\t\tconsole.time('' + this._messagePrefix + name);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'timeEnd',\n\t\tvalue: function timeEnd(name) {\n\t\t\tif (this.debug) {\n\t\t\t\tconsole.timeEnd('' + this._messagePrefix + name);\n\t\t\t}\n\t\t}\n\t}]);\n\n\treturn Logger;\n}())();\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*\n\tCopyright 2017 Kurt Wagner. All rights reserved\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\thttp://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n\n\nmodule.exports = function makeFetchListener(navigationPrefetch) {\n\treturn function fetchListener(event) {\n\t\tvar request = event.request;\n\t\tvar isNavigation = request.mode === 'navigate' || request.referrer === request.url;\n\n\t\tif (isNavigation) {\n\t\t\treturn void navigationPrefetch.prefetchRoutes(request);\n\t\t}\n\n\t\tvar prefetchedPromise = navigationPrefetch.provideRoutes(request);\n\t\tif (prefetchedPromise) {\n\t\t\tevent.respondWith(prefetchedPromise);\n\t\t}\n\t};\n};\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*\n\tCopyright 2017 Kurt Wagner. All rights reserved\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\thttp://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n\n\n/* eslint-disable max-len */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Route = __webpack_require__(4);\nvar Cache = __webpack_require__(3);\nvar logger = __webpack_require__(0);\n\nmodule.exports = function () {\n\tfunction Prefetch(_ref) {\n\t\tvar location = _ref.location;\n\n\t\t_classCallCheck(this, Prefetch);\n\n\t\tthis._cache = new Cache();\n\t\tthis._routes = [];\n\t\tthis._location = location;\n\t}\n\n\t_createClass(Prefetch, [{\n\t\tkey: 'serveRoute',\n\t\tvalue: function serveRoute(routePath, makeRequests) {\n\t\t\tvar routeURL = new URL(routePath, this._location.origin);\n\t\t\tvar route = new Route({\n\t\t\t\trouteURL: routeURL,\n\t\t\t\tmakeRequests: makeRequests\n\t\t\t});\n\t\t\tthis._routes.push(route);\n\t\t}\n\t}, {\n\t\tkey: 'provideRoutes',\n\t\tvalue: function provideRoutes(request) {\n\t\t\tvar responsePromise = this._cache.matchOnce(request);\n\t\t\tif (responsePromise) {\n\t\t\t\tlogger.log('Using cache for ' + request.url);\n\t\t\t\treturn responsePromise.then(function (response) {\n\t\t\t\t\treturn response.clone();\n\t\t\t\t});\n\t\t\t}\n\t\t\tlogger.log('Using network for ' + request.url);\n\t\t}\n\t}, {\n\t\tkey: 'prefetchRoutes',\n\t\tvalue: function prefetchRoutes(navigationRequest) {\n\t\t\tvar _this = this;\n\n\t\t\tthis._routes.forEach(function (route) {\n\t\t\t\tif (route.matchesRequest(navigationRequest)) {\n\t\t\t\t\tvar requests = route.makeRequests({ navigationRequest: navigationRequest });\n\t\t\t\t\t_this._cache.addAll(requests);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: 'debug',\n\t\tset: function set(debug) {\n\t\t\tlogger.debug = debug;\n\t\t}\n\t}]);\n\n\treturn Prefetch;\n}();\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*\n\tCopyright 2017 Kurt Wagner. All rights reserved\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\thttp://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar logger = __webpack_require__(0);\n\nmodule.exports = function () {\n\tfunction Cache() {\n\t\t_classCallCheck(this, Cache);\n\n\t\tthis._store = new Map();\n\t\tthis._cacheExpiryMS = 5000;\n\t}\n\n\t_createClass(Cache, [{\n\t\tkey: 'requests',\n\t\tvalue: function requests() {\n\t\t\treturn [].concat(_toConsumableArray(this._store.values())).map(function (_ref) {\n\t\t\t\tvar request = _ref.request;\n\n\t\t\t\treturn request;\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: 'matchOnce',\n\t\tvalue: function matchOnce(request) {\n\t\t\tvar found = this._store.get(request.url);\n\t\t\tif (found) {\n\t\t\t\tfound.cancelExpiration();\n\t\t\t\tthis._store.delete(request.url);\n\t\t\t}\n\t\t\treturn found ? found.responsePromise : null;\n\t\t}\n\t}, {\n\t\tkey: 'add',\n\t\tvalue: function add(request) {\n\t\t\tvar _this = this;\n\n\t\t\tvar url = request.url;\n\t\t\tlogger.log('Adding ' + url + ' to the cache');\n\t\t\tlogger.time('Prefetching ' + url + ' took');\n\t\t\tvar responsePromise = fetch(request).then(function (response) {\n\t\t\t\tlogger.timeEnd('Prefetching ' + url + ' took');\n\t\t\t\treturn response;\n\t\t\t});\n\n\t\t\tvar cancelExpiration = function () {\n\t\t\t\tvar timeoutId = setTimeout(function () {\n\t\t\t\t\tlogger.warn(url + ' expired and was never used!');\n\t\t\t\t\t_this._store.delete(url);\n\t\t\t\t}, _this._cacheExpiryMS);\n\t\t\t\treturn function () {\n\t\t\t\t\tclearTimeout(timeoutId);\n\t\t\t\t};\n\t\t\t}();\n\n\t\t\tthis._store.set(url, {\n\t\t\t\trequest: request,\n\t\t\t\tresponsePromise: responsePromise,\n\t\t\t\tcancelExpiration: cancelExpiration\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: 'addAll',\n\t\tvalue: function addAll(requests) {\n\t\t\tvar _this2 = this;\n\n\t\t\trequests.forEach(function (request) {\n\t\t\t\t_this2.add(request);\n\t\t\t});\n\t\t}\n\t}]);\n\n\treturn Cache;\n}();\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*\n\tCopyright 2017 Kurt Wagner. All rights reserved\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\thttp://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nmodule.exports = function () {\n\tfunction Route(_ref) {\n\t\tvar routeURL = _ref.routeURL,\n\t\t    makeRequests = _ref.makeRequests;\n\n\t\t_classCallCheck(this, Route);\n\n\t\tthis._routeURL = routeURL;\n\t\tthis._makeRequests = makeRequests;\n\t}\n\n\t_createClass(Route, [{\n\t\tkey: 'makeRequests',\n\t\tvalue: function makeRequests(_ref2) {\n\t\t\tvar navigationRequest = _ref2.navigationRequest;\n\n\t\t\tvar requests = new Set();\n\t\t\tthis._makeRequests(navigationRequest).forEach(function (rawUrl) {\n\t\t\t\tvar url = makeURL({\n\t\t\t\t\turlOrPath: rawUrl,\n\t\t\t\t\treferrer: getReferrerFromRequest(navigationRequest)\n\t\t\t\t});\n\t\t\t\trequests.add(makeRequest(url));\n\t\t\t});\n\t\t\treturn [].concat(_toConsumableArray(requests.values()));\n\t\t}\n\n\t\t/**\n   * Compare whether a given url is a match on the registered route. This is \n   * used to determine whether a navigational request matches this registered\n   * request and should thus preload linked resources.\n   *\n   * @param {Request} request -\n   * @return {Boolean} true if request matches\n   */\n\n\t}, {\n\t\tkey: 'matchesRequest',\n\t\tvalue: function matchesRequest(request) {\n\t\t\tvar requestURL = new URL(request.url);\n\t\t\tvar routeURL = this._routeURL;\n\n\t\t\t// Registered route always expects navigational requests to be from\n\t\t\t// the same origin. If the given request is not, then simply ignore\n\t\t\tif (routeURL.origin !== requestURL.origin) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// The path is then compared. From there the request builder can do as\n\t\t\t// it pleases with the requests parameters.\n\t\t\tvar pathToRegexp = __webpack_require__(6);\n\t\t\tvar regex = pathToRegexp(routeURL.pathname);\n\t\t\treturn !!requestURL.pathname.match(regex);\n\t\t}\n\t}]);\n\n\treturn Route;\n}();\n\nfunction makeURL(_ref3) {\n\tvar urlOrPath = _ref3.urlOrPath,\n\t    referrer = _ref3.referrer;\n\n\tif (!urlOrPath.startsWith('http')) {\n\t\t// if the given url does not start with http we're going to\n\t\t// assume it's a path relative to the origin of the worker\n\t\treturn new URL(urlOrPath, referrer);\n\t}\n\treturn new URL(urlOrPath);\n}\n\nfunction makeRequest(url) {\n\tvar headers = new Headers();\n\theaders.append('sw-navigation-prefetch', 'true');\n\n\treturn new Request(url, {\n\t\theaders: headers,\n\t\tcredentials: 'include'\n\t});\n}\n\nfunction getReferrerFromRequest(request) {\n\t// if no referrer than assume it's a navigation mode, in which case the\n\t// originating url of the request is the actual referrer\n\treturn request.referrer || request.url;\n}\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*\n\tCopyright 2017 Kurt Wagner. All rights reserved\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\thttp://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n\n\nvar Prefetch = __webpack_require__(2);\nvar makeFetchListener = __webpack_require__(1);\n\nself.navigationPrefetch = new Prefetch({\n\tlocation: self.location\n});\n\nself.addEventListener('fetch', makeFetchListener(self.navigationPrefetch));\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isarray = __webpack_require__(7)\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = options && options.delimiter || '/'\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    var next = str[index]\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var modifier = res[6]\n    var asterisk = res[7]\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var partial = prefix != null && next != null && next !== prefix\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var delimiter = res[2] || defaultDelimiter\n    var pattern = capture || group\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n    }\n  }\n\n  return function (obj, opts) {\n    var path = ''\n    var data = obj || {}\n    var options = opts || {}\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = '(?:' + token.pattern + ')'\n\n      keys.push(token)\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = prefix + '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/')\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\nmodule.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// sw-navigation-prefetch.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8f7258cd5517919a986e","/*\n\tCopyright 2017 Kurt Wagner. All rights reserved\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\thttp://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n'use strict';\n\nmodule.exports = new class Logger {\n\tconstructor() {\n\t\tthis.debug = false;\n\t\tthis._messagePrefix = 'sw-navigation-prefetch: ';\n\t}\n\t\n\twarn(...messages) {\n\t\tconsole.warn(this._messagePrefix, ...messages);\n\t}\n\t\n\tlog(...messages) {\n\t\tif (this.debug) {\n\t\t\tconsole.log(this._messagePrefix, ...messages);\n\t\t}\n\t}\n\t\n\ttime(name) {\n\t\tif (this.debug) {\n\t\t\tconsole.time(`${this._messagePrefix}${name}`);\n\t\t}\n\t}\n\t\n\ttimeEnd(name) {\n\t\tif (this.debug) {\n\t\t\tconsole.timeEnd(`${this._messagePrefix}${name}`);\n\t\t}\n\t}\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/logger.js","/*\n\tCopyright 2017 Kurt Wagner. All rights reserved\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\thttp://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n'use strict';\n\nmodule.exports = function makeFetchListener(navigationPrefetch) {\n\treturn function fetchListener(event) {\n\t\tconst request = event.request;\n\t\tconst isNavigation = request.mode === 'navigate' || \n\t\t                     request.referrer === request.url;\n\t\t\n\t\tif (isNavigation) {\n\t\t\treturn void navigationPrefetch.prefetchRoutes(request);\n\t\t}\n\t\t\n\t\tconst prefetchedPromise = navigationPrefetch.provideRoutes(request);\n\t\tif (prefetchedPromise) {\n\t\t\tevent.respondWith(prefetchedPromise);\n\t\t}\n\t};\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/listeners/fetch.js","/*\n\tCopyright 2017 Kurt Wagner. All rights reserved\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\thttp://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n'use strict';\n\n/* eslint-disable max-len */\n\nconst Route = require('./route');\nconst Cache = require('./cache');\nconst logger = require('../logger');\n\nmodule.exports = class Prefetch {\n\tconstructor({location}) {\n\t\tthis._cache = new Cache();\n\t\tthis._routes = [];\n\t\tthis._location = location;\n\t}\n\t\n\tset debug(debug) {\n\t\tlogger.debug = debug;\n\t}\n\n\tserveRoute(routePath, makeRequests) {\n\t\tconst routeURL = new URL(routePath, this._location.origin);\n\t\tconst route = new Route({\n\t\t\trouteURL,\n\t\t\tmakeRequests,\n\t\t});\n\t\tthis._routes.push(route);\n\t}\n\n\tprovideRoutes(request) {\n\t\tconst responsePromise = this._cache.matchOnce(request);\n\t\tif (responsePromise) {\n\t\t\tlogger.log(`Using cache for ${request.url}`);\n\t\t\treturn responsePromise.then((response) => {\n\t\t\t\treturn response.clone();\n\t\t\t});\n\t\t}\n\t\tlogger.log(`Using network for ${request.url}`);\n\t}\n\n\tprefetchRoutes(navigationRequest) {\n\t\tthis._routes.forEach((route) => {\n\t\t\tif (route.matchesRequest(navigationRequest)) {\n\t\t\t\tconst requests = route.makeRequests({navigationRequest});\n\t\t\t\tthis._cache.addAll(requests);\n\t\t\t}\n\t\t});\n\t}\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/models/prefetch.js","/*\n\tCopyright 2017 Kurt Wagner. All rights reserved\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\thttp://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n'use strict';\n\nconst logger = require('../logger');\n\nmodule.exports = class Cache {\n\tconstructor() {\n\t\tthis._store = new Map();\n\t\tthis._cacheExpiryMS = 5000;\n\t}\n\t\n\trequests() {\n\t\treturn [...this._store.values()].map(({request}) => {\n\t\t\treturn request;\n\t\t});\n\t}\n\t\n\tmatchOnce(request) {\n\t\tconst found = this._store.get(request.url);\n\t\tif (found) {\n\t\t\tfound.cancelExpiration();\n\t\t\tthis._store.delete(request.url);\n\t\t}\n\t\treturn found ? found.responsePromise : null;\n\t}\n\t\n\tadd(request) {\n\t\tconst url = request.url;\n\t\tlogger.log(`Adding ${url} to the cache`);\n\t\tlogger.time(`Prefetching ${url} took`);\n\t\tconst responsePromise = fetch(request).then((response) => {\n\t\t\tlogger.timeEnd(`Prefetching ${url} took`);\n\t\t\treturn response;\n\t\t});\n\t\t\n\t\tconst cancelExpiration = (() => {\n\t\t\tconst timeoutId = setTimeout(() => {\n\t\t\t\tlogger.warn(`${url} expired and was never used!`);\n\t\t\t\tthis._store.delete(url);\n\t\t\t}, this._cacheExpiryMS);\n\t\t\treturn () => {\n\t\t\t\tclearTimeout(timeoutId);\n\t\t\t};\n\t\t})();\n\t\t\n\t\tthis._store.set(url, {\n\t\t\trequest,\n\t\t\tresponsePromise,\n\t\t\tcancelExpiration,\n\t\t});\n\t}\n\t\n\taddAll(requests) {\n\t\trequests.forEach((request) => {\n\t\t\tthis.add(request);\n\t\t});\n\t}\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/models/cache.js","/*\n\tCopyright 2017 Kurt Wagner. All rights reserved\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\thttp://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n'use strict';\n\nmodule.exports = class Route {\n\tconstructor({routeURL, makeRequests}) {\n\t\tthis._routeURL = routeURL;\n\t\tthis._makeRequests = makeRequests;\n\t}\n\t\n\tmakeRequests({navigationRequest}) {\n\t\tconst requests = new Set();\n\t\tthis._makeRequests(navigationRequest).forEach((rawUrl) => {\n\t\t\tconst url = makeURL({\n\t\t\t\turlOrPath: rawUrl,\n\t\t\t\treferrer: getReferrerFromRequest(navigationRequest),\n\t\t\t});\n\t\t\trequests.add(makeRequest(url));\n\t\t});\n\t\treturn [...requests.values()];\n\t}\n\t\n\t/**\n\t * Compare whether a given url is a match on the registered route. This is \n\t * used to determine whether a navigational request matches this registered\n\t * request and should thus preload linked resources.\n\t *\n\t * @param {Request} request -\n\t * @return {Boolean} true if request matches\n\t */\n\tmatchesRequest(request) {\n\t\tconst requestURL = new URL(request.url);\n\t\tconst routeURL = this._routeURL;\n\t\t\t\t\n\t\t// Registered route always expects navigational requests to be from\n\t\t// the same origin. If the given request is not, then simply ignore\n\t\tif (routeURL.origin !== requestURL.origin) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t// The path is then compared. From there the request builder can do as\n\t\t// it pleases with the requests parameters.\n\t\tconst pathToRegexp = require('path-to-regexp');\n\t\tconst regex = pathToRegexp(routeURL.pathname);\t\t\n\t\treturn !!requestURL.pathname.match(regex);\n\t}\n};\n\nfunction makeURL({urlOrPath, referrer}) {\n\tif (!urlOrPath.startsWith('http')) {\n\t\t// if the given url does not start with http we're going to\n\t\t// assume it's a path relative to the origin of the worker\n\t\treturn new URL(urlOrPath, referrer);\n\t}\n\treturn new URL(urlOrPath);\n}\n\nfunction makeRequest(url) {\n\tconst headers = new Headers();\n\theaders.append('sw-navigation-prefetch', 'true');\n\t\n\treturn new Request(url, {\n\t\theaders: headers,\n\t\tcredentials: 'include',\n\t});\n}\n\nfunction getReferrerFromRequest(request) {\n\t// if no referrer than assume it's a navigation mode, in which case the\n\t// originating url of the request is the actual referrer\n\treturn request.referrer || request.url;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/models/route.js","/*\n\tCopyright 2017 Kurt Wagner. All rights reserved\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\thttp://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n'use strict';\n\nconst Prefetch = require('./models/prefetch');\nconst makeFetchListener = require('./listeners/fetch');\n\nself.navigationPrefetch = new Prefetch({\n\tlocation: self.location,\n});\n\nself.addEventListener('fetch', makeFetchListener(self.navigationPrefetch));\n\n\n\n// WEBPACK FOOTER //\n// ./lib/sw-navigation-prefetch.js","var isarray = require('isarray')\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = options && options.delimiter || '/'\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    var next = str[index]\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var modifier = res[6]\n    var asterisk = res[7]\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var partial = prefix != null && next != null && next !== prefix\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var delimiter = res[2] || defaultDelimiter\n    var pattern = capture || group\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n    }\n  }\n\n  return function (obj, opts) {\n    var path = ''\n    var data = obj || {}\n    var options = opts || {}\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = '(?:' + token.pattern + ')'\n\n      keys.push(token)\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = prefix + '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/')\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/path-to-regexp/index.js\n// module id = 6\n// module chunks = 0","module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/path-to-regexp/~/isarray/index.js\n// module id = 7\n// module chunks = 0"],"sourceRoot":""}